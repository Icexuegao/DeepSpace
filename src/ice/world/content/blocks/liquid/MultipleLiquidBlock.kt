package ice.world.content.blocks.liquidimport arc.func.Funcimport arc.func.Provimport arc.graphics.Colorimport arc.scene.ui.layout.Tableimport arc.struct.OrderedMapimport ice.world.content.blocks.abstractBlocks.IceBlockimport ice.world.draw.DrawBuildimport ice.world.draw.DrawMultiimport mindustry.gen.Buildingimport mindustry.graphics.Palimport mindustry.type.Liquidimport mindustry.ui.Barimport mindustry.world.blocks.liquid.LiquidBlockimport mindustry.world.draw.DrawRegionimport mindustry.world.meta.BlockGroupimport kotlin.math.minopen class MultipleLiquidBlock(name: String) : IceBlock(name) {    init {        update = true        hasLiquids = true        outputsLiquid = false        group = BlockGroup.liquids        buildType = Prov(::MultipleBlockBuild)        drawers = DrawMulti(DrawRegion("-bottom"), DrawBuild<MultipleBlockBuild> {            var liquid: Liquid? = null            liquids.each { liquida, amount ->                liquid = liquida            }            liquid?.let {                LiquidBlock.drawTiledFrames(size, x, y, 0f, 0f, 0f, 0f, liquid, liquids.get(it) / liquidCapacity)            }        }, DrawRegion("-top"))    }    inner class MultipleBlockBuild : IceBuild() {        private var icebarMap: OrderedMap<String, Func<MultipleBlockBuild, Bar>> = OrderedMap()        override fun acceptLiquid(source: Building, liquid: Liquid): Boolean {            return liquids.get(liquid) < liquidCapacity        }        override fun transferLiquid(next: Building, amount: Float, liquid: Liquid?) {            val flow = min(liquids.get(liquid), min(next.block.liquidCapacity - next.liquids[liquid], amount))            if (next.acceptLiquid(this, liquid)) {                next.handleLiquid(this, liquid, flow)                liquids.remove(liquid, flow)            }        }        override fun drawSelect() {            icebarMap.clear()            iceAddBar("health") { entity: Building ->                Bar("stat.health", Pal.health) { entity.healthf() }.blink(Color.white)            }            liquids.each { liquid, amount ->                if (amount < 1) icebarMap.remove("liquid-" + liquid.name)                if (amount > 1 && !icebarMap.containsKey("liquid-" + liquid.name)) addLiquidBar(liquid)            }            super.drawSelect()        }        private fun addLiquidBar(liquid: Liquid) {            iceAddBar("liquid-" + liquid.name) { entity: Building ->                if (!liquid.unlockedNow()) null else Bar({ liquid.localizedName }, { liquid.barColor() },                    { entity.liquids.get(liquid) / liquidCapacity })            }        }        private fun iceAddBar(name: String, sup: Func<MultipleBlockBuild, Bar>) {            icebarMap.put(name, sup)        }        override fun displayBars(table: Table) {            for (bar: Func<MultipleBlockBuild, Bar> in icebarMap.values()) {                table.add(bar.get(this)).growX().row()            }        }    }}